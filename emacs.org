#+TITLE:  Emacs Configuration File
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com

* Introduction

  This is my =.emacs= file, written using [[http://www.orgmode.org][org-mode]], so that I can
  organize it and take notes on all the complexity.

#+BEGIN_HTML
  <p>
    You can download the <a href="dot-emacs.org">original org-mode
    file</a> or view the <a href="dot-emacs.el">tangled end results</a>.
  </p>
#+END_HTML

  If you are playing around with the =org-mode= version, note:

  - The =tab= key opens/close a particular section
  - Shift + =tab= cycles between the outline and full text
  - Render it with:  =C-c C-v t=
  - Creates a file:  =~/.emacs-ext.el=

** Emacs Executable

   This file is really a /script/ that requires version 24 of Emacs.
   While I often use [[http://emacsformacosx.com/builds][Emacs for Mac]], lately, I've been building from
   [[http://brew.sh/][Homebrew]] with the following:

   #+BEGIN_EXAMPLE
     brew install emacs --cocoa --srgb --with-gnutls
     brew linkapps
   #+END_EXAMPLE

   Not only does this install the latest version of Emacs in
   =/usr/local/bin/emacs=, but it also links a GUI version in
   =/Application/Emacs.app=. Goody.

** Loading this File

   To "load" the contents of this file, add the following to =$HOME/.emacs=:

#+BEGIN_EXAMPLE
  ;; Load our Literate Programming version of our Dot Emacs
  ;; file, from file: ~/Work/dot-files/emacs.org
  (unless (boundp 'aquamacs-version)
    (load-file "~/.emacs.d/elisp/init-main.el")

    (when (window-system)
      (require 'init-mac))

    (server-start))
#+END_EXAMPLE

   *Note:* I only load this from a "normal" Emacs distribution, which allows
   me to play around with [[http://aquamacs.org/][Aquamacs]] and [[http://eschulte.github.io/emacs-starter-kit/][Starter Kits]] for recommendations
   to people new to Emacs.

** Editing Warning

  Begin this initialization script with a warning not to edit the
  generated file:

#+NAME: Note
#+BEGIN_SRC elisp :comments off
  ;;; ------------------------------------------
  ;;; Do not edit the generated file, as it has
  ;;; been generated, as a tangled file, by the
  ;;; fandifluous org-mode.
  ;;;
  ;;; Source: ~/Work/dot-files/emacs.org
  ;;; ------------------------------------------
#+END_SRC

* General Settings
** My Directory Location

   Normally, the =user-emacs-directory= stores everything in a
   =.emacs.d= directory in the home directory, however, Aquamacs
   overrides that, and since I now feel the need to use these settings
   for both editors (sure feels like XEmacs all over again).

   Any way, I have a new global variable for that:

   #+BEGIN_SRC elisp
     (defconst ha/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))

     (defun ha/emacs-subdirectory (d) (expand-file-name d ha/emacs-directory))
   #+END_SRC

** Directory Structure

   In case this is the first time running this on a computer, we need
   to make sure the following directories have been created.

#+BEGIN_SRC elisp
  (let* ((subdirs '("elisp" "backups" "snippets" "ac-dict"))
         (fulldirs (mapcar (lambda (d) (ha/emacs-subdirectory d)) subdirs)))
    (dolist (dir fulldirs)
      (when (not (file-exists-p dir))
        (message "Make directory: %s" dir)
        (make-directory dir))))
#+END_SRC

** Customization Section

   While I would rather program my configurations, sometimes the Emacs
   menu system is "good enough", but I want it in its own file:

#+BEGIN_SRC elisp
  (setq custom-file (expand-file-name "custom.el" ha/emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

** Setting up the Load Path

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=

#+BEGIN_SRC elisp
  (add-to-list 'load-path (ha/emacs-subdirectory "elisp"))
#+END_SRC

   Load up my special collection of enhancements to Emacs Lisp:

   #+BEGIN_SRC elisp
   (require 'init-support)
   (require 'cl)
   #+END_SRC

* Package Initialization
** Package Manager

   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
   so conservative, we need to add more repositories to get all the
   sweet goodness, I demand.

#+BEGIN_SRC elisp
  (require 'package)

  (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                           ("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "http://melpa.milkbox.net/packages/")
                           ("marmalade" . "http://marmalade-repo.org/packages/")))
#+END_SRC

   While we can now do a =package-list-packages=, you can install and
   everything is good, however, we can't =require= any of these
   packages (in order to customize them in this file) until we do
   this:

#+BEGIN_SRC elisp
  (package-initialize)
  (package-refresh-contents)
#+END_SRC

   Not sure why the package management system doesn't come with a
   programmatic way to specify what packages should be installed. Oh
   yeah, this is pretty new. Looks like everyone just rolls there own,
   so this is mine.

#+BEGIN_SRC elisp
  (defun packages-install (packages)
    "Given a list of packages, this will install them from the standard locations."
    (let ((to-install (inverse-filter 'package-installed-p packages)))
      (when to-install
        (package-refresh-contents)
        (dolist (it to-install)
            (package-install it)
        (delete-other-windows)))))
#+END_SRC

** Installing Extra Packages

   This means that at any point in my configuration file, I can
   specify a list of packages to make sure they are installed.

#+BEGIN_SRC elisp
  (packages-install
                 '(auto-complete
                   ack-and-a-half
                   dired-details
                   color-identifiers-mode  ;; Color variables differently
                   epl
                   env-var-import
                   esh-buf-stack
                   expand-region
                   flx
                   flx-ido
                   flycheck
                   flycheck-color-mode-line
                   git-blame
                   git-commit-mode
                   git-gutter-fringe
                   gitconfig-mode
                   gitignore-mode
                   graphviz-dot-mode
                   hungry-delete
                   ido-vertical-mode
                   iy-go-to-char
                   linum-relative
                   magit
                   markdown-mode
                   multiple-cursors
                   paredit
                   redo+             ;; If not installed, edit mac-key-mode
                   smex
                   thesaurus
                   undo-tree
                   visual-regexp
                   yasnippet))
#+END_SRC

* Variables

   General settings about me that other packages can use. The biggest
   problem is guessing my email address based on what computer I am using:

#+BEGIN_SRC elisp
  (if (equal "howard.abrams" user-login-name)
      (setq user-mail-address "howard.abrams@workday.com")
    (setq user-mail-address "howard.abrams@gmail.com"))
#+END_SRC

** Tabs vs Spaces

    I have learned to distrust tabs in my source code, so let's make
    sure that we only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

#+BEGIN_SRC elisp
  (setq-default indent-tabs-mode nil)
  (setq tab-width 2)
#+END_SRC

    Make tab key do indent first then completion.

#+BEGIN_SRC elisp
  (setq-default tab-always-indent 'complete)
#+END_SRC

** Aggressive Auto Indention

   Automatically indent without use of the tab found in [[http://endlessparentheses.com/permanent-auto-indentation.html][this article]],
   and seems to be quite helpful for many types of programming
   languages.

   To begin, we create a function that can indent a function by
   calling =indent-region= on the beginning and ending points of a
   function.

   #+BEGIN_SRC elisp
     (defun indent-defun ()
       "Indent current defun.
     Do nothing if mark is active (to avoid deactivaing it), or if
     buffer is not modified (to avoid creating accidental
     modifications)."
       (interactive)
       (unless (or (region-active-p)
                   buffer-read-only
                   (null (buffer-modified-p)))
         (let ((l (save-excursion (beginning-of-defun 1) (point)))
               (r (save-excursion (end-of-defun 1) (point))))
           (cl-letf (((symbol-function 'message) #'ignore))
             (indent-region l r)))))
   #+END_SRC

   Next, create a hook that will call the =indent-defun= with every
   command call:

   #+BEGIN_SRC elisp
     (defun activate-aggressive-indent ()
       "Locally add `ha/indent-defun' to `post-command-hook'."
       (add-hook 'post-command-hook
                 'indent-defun nil 'local))
   #+END_SRC

   The trick is to add the following to each programming hook:

   #+BEGIN_SRC elisp
      (add-hook 'emacs-lisp-mode-hook 'activate-aggressive-indent)
   #+END_SRC

* Display Settings

   I've been using Emacs for many years, and appreciate a certain
   minimalist approach to its display. While you can turn these off
   with the menu items now, it is just as easy to set them here.

#+BEGIN_SRC elisp
  (setq initial-scratch-message "") ;; Uh, I know what Scratch is for
  (setq visible-bell t)             ;; Get rid of the beeps

  (unless (window-system)
    (menu-bar-mode 0))              ;; No menus... but only in text mode

  (when (window-system)
    (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
    (when (fboundp 'horizontal-scroll-bar-mode)
      (horizontal-scroll-bar-mode -1))
    (scroll-bar-mode -1))            ;; Scrollbars are waste screen estate
#+END_SRC

   Most of the display settings actually come from the [[file:emacs-mac.org][Mac initialization file]].

** Mode Line

    My [[file:emacs-mode-line.org][mode-line code]] is now more complex in order to make it more simpler.

#+BEGIN_SRC elisp
  (require 'init-mode-line)
#+END_SRC

* Key Bindings
** Function Key Definitions

   Clearly, the most important keybindings are the function keys,
   right? Here is my list of needs:

   - *F1* - Help? Isn't Control-H good enough?
   - *F2* - Standard alternate meta key with lots of bindings
   - *F3* - Define a keyboard macro
   - *F4* - Replay a keyboard macro
   - *F5* - Repeat the last command ...
   - *F6* - Repeat the last command entered at the M-x prompt
   - *F7* - Switch to another window ... Shift goes the other way.
   - *F8* - Switch to buffer
   - *F9* - My other meta key for changing colors and other odd
     bindings that I actually don't use that often

   #+BEGIN_SRC elisp
     (global-set-key (kbd "<f5>") 'repeat)
     (global-set-key (kbd "<f6>") 'repeat-complex-command)
     (global-set-key (kbd "<f7>") 'other-window)
     (global-set-key (kbd "<f8>") 'ido-switch-buffer)

     (require 'ace-jump-mode)
     (define-key global-map (kbd "S-<f7>") 'ace-jump-mode)
   #+END_SRC

   Set up [[https://github.com/abo-abo/ace-window][ace-window]] mode:

   #+BEGIN_SRC elisp
     (when (require 'ace-window nil t)
           (global-set-key (kbd "<f7>") 'ace-window)
           (global-set-key (kbd "C-<f7>") (lambda () (interactive) (ace-window 4)))
           (global-set-key (kbd "M-<f7>") (lambda () (interactive) (ace-window 8))))
   #+END_SRC

   At some point, I will want to choose window labels based on the
   right hand (since F7) is on the left side of my keyboards.

   #+BEGIN_SRC elisp :tangle no
   (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
   #+END_SRC

   I like [[https://github.com/KMahoney/kpm-list][kpm-list]] a bit better than =ibuffer=, but I really don’t use
   either more than =ido-switch-buffer=. Still:

   #+BEGIN_SRC elisp
   (if (require 'kpm-list nil t)
       (global-set-key (kbd "S-<f8>") 'kpm-list)
     (global-set-key (kbd "S-<f8>") 'ibuffer))
   #+END_SRC
*** F2 and F9 Helpers

    The F9 prefix is scattered about my config files.

    #+BEGIN_SRC elisp
      (define-prefix-command 'personal-global-map)
      (global-set-key (kbd "<f9>") 'personal-global-map)

      (define-key personal-global-map (kbd "b") 'bury-buffer)
    #+END_SRC

    Unlike the *F9* bindings, all the *F2* key-bindings happen in a
    single [[file:emacs-f2.org][library file]]:

    #+BEGIN_SRC elisp
      (require 'init-f2)
    #+END_SRC

*** Auto Hiding Functions

    Big, structured file, like source code, hide all of the functions,
    and selectively reveal them, using [[http://www.emacswiki.org/emacs/HideShow][hide-show-mode]]. I don't like
    the complicated key-bindings, so I through them on the <f9>:

    #+BEGIN_SRC elisp
      (defun ha-hs-hide-all ()
        "Wrapper around 'hs-hide-all' that turns on the minor mode."
        (interactive)
        (hs-minor-mode t)
        (hs-hide-all))

      (define-key personal-global-map (kbd "M-H") 'ha-hs-hide-all)
      (define-key personal-global-map (kbd "H") 'hs-hide-block)
      (define-key personal-global-map (kbd "M-V") 'hs-show-all)
      (define-key personal-global-map (kbd "V") 'hs-show-block)
    #+END_SRC

    While 'S' does make sense for /showing/, I'm already using that
    for 'Stop'. Besides, 'viewing' isn't a bad mnemonic.

*** Easy Highlighting

    I like the ability to highlight random text.

    #+BEGIN_SRC elisp
      (define-key personal-global-map (kbd "h") 'highlight-regexp)
      (define-key personal-global-map (kbd "u") 'unhighlight-regexp)
    #+END_SRC

    May get specific highlights automatically for certain files. We
    begin by highlighting lines in *.log files.

    #+BEGIN_SRC elisp
      (defun highlite-it ()
        "Highlight certain lines in specific files. Currently, only log files are supported."
        (interactive)
        (when (equal "log" (file-name-extension (buffer-file-name)))
              (hi-lock-mode 1)
              (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
              (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b)))

      (add-hook 'find-file-hook 'highlite-it)
    #+END_SRC

    Turn on specific word groupings for specific occasions. We begin
    with highlighting keywords I use during note-taking sessions at
    the end of a sprint.

    #+BEGIN_SRC elisp
      (defun ha/sprint-retrospective-highlighting ()
        "Highlights the good, the bad and the improvements to make when taking notes."
        (interactive)
        (hi-lock-mode t)
        (highlight-lines-matching-regexp "^   [-*] " 'hi-black-b)
        (highlight-phrase "TODO:?" 'hi-black-b)
        (highlight-regexp "(?Good)?:?" 'hi-green-b)
        (highlight-regexp "(?Bad)?:?" 'hi-red-b)
        (highlight-regexp "Imp\\(rove\\)?:" 'hi-blue-b))
    #+END_SRC

*** Controlling Windows

    Often, while on my laptop, I want the current window to be ‘large
    enough for work’, and this is bound to =<f9> .= (period).

    #+BEGIN_SRC elisp
      (define-key personal-global-map (kbd ",") 'ha/window-standard-size)
    #+END_SRC

    If I've enlarged the window, I can restore that window to its
    original size, so this requires a /buffer local variable/:

    #+BEGIN_SRC elisp
      (make-variable-buffer-local 'window-width-original)
    #+END_SRC

    Now a function that either changes the width to 80, or back to the
    original size if already at 80.

    #+BEGIN_SRC elisp
      (defun ha/window-standard-size (arg)
        "Sets the size of the current window to 80 characters, unless
      it already is 80 characters, in which case, set it back to its
      previous size. A prefix ARG can be given to set the window to a
      particular width."
        (interactive "p")

        ;; If not already set, let's store the current window width in our
        ;; buffer-local variable.
        (if (not (local-variable-p 'window-width-original))
            (setq window-width-original (window-width)))

        ;; The 'goal' is 80 unless we get a better argument, C-u 60 ...
        (let* ((goal-width (if (> arg 8) arg 80))
               (new-width (- goal-width (window-width))))

          (if (= new-width 0)    ; Already enlarged? Restore:
              (enlarge-window-horizontally (- window-width-original goal-width))
            (enlarge-window-horizontally new-width))))
    #+END_SRC

** Other Key Bindings

   After picking up an Advantage Kinesis, I decided that I wanted to
   redo some of the bindings to make it easier on me...mainly because
   the Shift key is now really, really hard to reach.

   #+BEGIN_SRC elisp
     (global-set-key (kbd "M-<left>") 'beginning-of-line)
     (global-set-key (kbd "M-<right>") 'end-of-line)
     (global-set-key (kbd "C-M-<left>") 'beginning-of-buffer)
     (global-set-key (kbd "C-M-<right>") 'end-of-buffer)
   #+END_SRC

** Unfill Paragraph

   Unfilling a paragraph joins all the lines in a paragraph into a
   single line. Taken from [[http://www.emacswiki.org/UnfillParagraph][here]].

   #+BEGIN_SRC elisp
    (defun unfill-paragraph ()
      "Takes a multi-line paragraph and makes it into a single line of text."
      (interactive)
      (let ((fill-column (point-max)))
        (fill-paragraph nil)))

    ;; Handy key definition
    (define-key global-map "\M-Q" 'unfill-paragraph)
   #+END_SRC

** General Behavior Fixes

   The subtle changes I've been making to Emacs behavior has grown
   until I felt I should move it into [[file:emacs-fixes.org][its own source file]].

   #+BEGIN_SRC elisp
   (require 'init-fixes)
   #+END_SRC

** Multiple Cursors

   While I'm not sure how often I will use [[https://github.com/emacsmirror/multiple-cursors][multiple-cursors]] project,
   I'm going to try to remember it is there. It doesn't have any
   default keybindings, so I set up the suggested:

#+BEGIN_SRC elisp
  (when (require 'multiple-cursors nil t)
        (global-set-key (kbd "C->") 'mc/mark-next-like-this)
        (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
        (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this))
#+END_SRC

** Expand Region

    Wherever you are in a file, and whatever the type of file, you
    can slowly increase a region selection by logical segments.

    #+BEGIN_SRC elisp
      (require 'expand-region)
      (global-set-key (kbd "C-=") 'er/expand-region)
    #+END_SRC

    This works really well with other commands, including
    [[https://github.com/Bruce-Connor/fancy-narrow][fancy-narrow]], where I can visually high-light a section of a
    buffer. Great for code-reviews and other presentations.

    #+BEGIN_SRC elisp
      (when (require 'fancy-narrow nil t)
        (defun ha/highlight-block ()
          "Highlights a 'block' in a buffer defined by the first blank
           line before and after the current cursor position. Uses the
           'fancy-narrow' mode to high-light the block."
          (interactive)
          (let (cur beg end)
            (setq cur (point))
            (setq end (or (re-search-forward  "^\s*$" nil t) (point-max)))
            (goto-char cur)
            (setq beg (or (re-search-backward "^\s*$" nil t) (point-min)))
            (fancy-narrow-to-region beg end)
            (goto-char cur)))

        (defun ha/highlight-section (num)
          "If some of the buffer is highlighted with the 'fancy-narrow'
           mode, then un-highlight it by calling 'fancy-widen'.

           If region is active, call 'fancy-narrow-to-region'.

           If given a prefix value, C-u, highlight the current
           block (delimited by blank lines). Otherwise, called
           'fancy-narrow-to-defun, to highlight current function."
          (interactive "p")
          (cond
           ((fancy-narrow-active-p) (fancy-widen))
           ((> num 1)               (ha-highlight-block))
           ((region-active-p)       (fancy-narrow-to-region (region-beginning) (region-end)))
           ;; Want to do something special in org-mode? Probably...
           ;; ((derived-mode-p 'org-mode) ...)
           (t                       (fancy-narrow-to-defun))))

        (global-set-key (kbd "C-M-+") 'ha/highlight-section))
    #+END_SRC

** Block Wrappers

    The =M-(= binding to =insert-pair= is great, but we often need to
    wrap other commands. Thankfully, =insert-pair= is up to the task
    by simply having new bindings.

#+BEGIN_SRC elisp
  (global-set-key (kbd "M-[") 'insert-pair)
  (global-set-key (kbd "M-{") 'insert-pair)
  (global-set-key (kbd "M-<") 'insert-pair)
  (global-set-key (kbd "M-'") 'insert-pair)
  (global-set-key (kbd "M-`") 'insert-pair)
  (global-set-key (kbd "M-\"") 'insert-pair)
#+END_SRC

    But in order to wrap text in a more general way (with just about
    any textual string), we need something more. Especially with the
    =expand-region= command, wrapping a logical block of text with a
    beginning and ending string really makes sense.

#+BEGIN_SRC elisp
  (defun surround (start end txt)
   "Wraps the specified region (or the current 'symbol / word'
  with some textual markers that this function requests from the
  user. Opening-type text, like parens and angle-brackets will
  insert the matching closing symbol.

  This function also supports some org-mode wrappers:

    - `#s` wraps the region in a source code block
    - `#e` wraps it in an example block
    - `#q` wraps it in an quote block"
    (interactive "r\nsEnter text to surround: " start end txt)

    ;; If the region is not active, we use the 'thing-at-point' function
    ;; to get a "symbol" (often a variable or a single word in text),
    ;; and use that as our region.

    (if (not (region-active-p))
        (let ((new-region (bounds-of-thing-at-point 'symbol)))
          (setq start (car new-region))
          (setq end (cdr new-region))))

      ;; We create a table of "odd balls" where the front and the end are
      ;; not the same string.
    (let* ((s-table '(("#e" . ("#+BEGIN_EXAMPLE\n" "\n#+END_EXAMPLE") )
                      ("#s" . ("#+BEGIN_SRC \n"    "\n#+END_SRC") )
                      ("#q" . ("#+BEGIN_QUOTE\n"   "\n#+END_QUOTE"))
                      ("<"  . ("<" ">"))
                      ("("  . ("(" ")"))
                      ("{"  . ("{" "}"))
                      ("["  . ("[" "]"))))    ; Why yes, we'll add more
           (s-pair (assoc-default txt s-table)))

      ;; If txt doesn't match a table entry, then the pair will just be
      ;; the text for both the front and the back...
      (unless s-pair
        (setq s-pair (list txt txt)))

      (save-excursion
        (narrow-to-region start end)
        (goto-char (point-min))
        (insert (car s-pair))
        (goto-char (point-max))
        (insert (cadr s-pair))
        (widen))))

  (global-set-key (kbd "C-+") 'surround)
#+END_SRC

  To make it easier to call from other functions, let's wrap that
  wrapper:

#+BEGIN_SRC elisp
  (defun surround-text (txt)
    (if (region-active-p)
        (surround (region-beginning) (region-end) txt)
      (surround nil nil txt)))
#+END_SRC

** Round Quotes

   While reading [[http://endlessparentheses.com/prettify-your-quotation-marks.html][this article]], I became intrigued with the idea of
   using real “quotes” in my org-mode files, but instead of inserting
   both pairs with the cursor in the middle, I decided that I would
   insert an /open/ quote unless an /open/ quote had already been
   inserted previously in the paragraph.

   Whether inserting “double” or ‘single’ quotes, the behavior is
   similar, so we will create a function for the behavior and pass in
   the strings to match:

   #+BEGIN_SRC elisp
     (defun ha/matching-quotes (open close normal override)
       "Insert OPEN or CLOSE depending whether paragraph contains a dangling OPEN character before.
     Inserts a straight NORMAL charactedr With prefix argument OVERRIDE.  If
     inside a code-block, simply calls `self-insert-command'."

       ;; If a prefix is given or we are in org-mode in a source block,
       ;; we just do the regular thing and print " as normal.
       (if (or override
               (and (derived-mode-p 'org-mode) (org-in-src-block-p)))
           (call-interactively 'self-insert-command)

         ;; Otherwise we need to figure out the beginning of the paragraph
         ;; And if there has been an opened quote in that paragraph:
         (let* ((quote-regexp (concat "[" open close "]"))  ; Look like: "[‘’]"
                (paragraph-beginning (save-excursion
                                       (org-backward-paragraph)
                                       (point)))
                (opened-quote      (save-excursion
                                     (re-search-backward quote-regexp paragraph-beginning t)
                                     (looking-at open))))

           ;; Currently on a closed round quote, skip it.
           (if (looking-at (concat close "[/=_\\*]?"))
               (goto-char (match-end 0))
             (if (or opened-quote (looking-back "[A-Za-z]"))
                 (insert close)
               (insert open))))))
   #+END_SRC

   Create two functions that match the quote styles, by passing in the
   following Unicode characters:

   - =DOUBLE COMMA QUOTATION MARK=
   - =DOUBLE TURNED COMMA QUOTATION MARK=
   - =SINGLE COMMA QUOTATION MARK=
   - =SINGLE TURNED COMMA QUOTATION MARK=

   #+BEGIN_SRC elisp
     (defun ha/round-quotes (regular)
       "Insert “ or ” depending whether paragraph contains a dangling “ character before.
     With prefix argument REGULAR, insert a straight \" character, i.e. C-1 \".  If
     inside a code-block, simply calls `self-insert-command'."
       (interactive "P")
       (ha/matching-quotes "“" "”" "\"" regular))

     (defun ha/round-single-quotes (regular)
       "Insert ‘ or ’ depending whether paragraph contains a dangling ‘ character before.
     With prefix argument REGULAR, insert a straight ' character, i.e. C-1 '.  If
     inside a code-block, simply calls `self-insert-command'."
       (interactive "P")
       (ha/matching-quotes "‘" "’" "'" regular))
   #+END_SRC

   Bind these to the standard ' and " keys:

   #+BEGIN_SRC elisp
     (add-hook 'org-mode-hook
               (lambda ()
                 (define-key org-mode-map "\"" 'ha/round-quotes)
                 (define-key org-mode-map  "'" 'ha/round-single-quotes)))
   #+END_SRC

** Kill Entire Lines

   While =C-k= kills text to the end of the line, what about killing
   text before the point?

   #+BEGIN_SRC elisp
     (defun ha/kill-line-before ()
       "Kills text from the current cursor position to the beginning
     of the current line."
       (interactive)
       (kill-region (point-at-bol) (point)))

     (global-set-key (kbd "C-S-K") 'ha/kill-line-before)
   #+END_SRC

   According to [[http://endlessparentheses.com/kill-entire-line-with-prefix-argument.html][this article]], killing the rest of the line is fine,
   but =C-3 C-k= kills only 2½ lines. Not so useful.

   This creates a macro that moves to the beginning of the line and
   then calls a function given to it. Quite an interesting approach:

  #+BEGIN_SRC elisp
    (defmacro bol-with-prefix (function)
      "Define a new function which calls FUNCTION.
    Except it moves to beginning of line before calling FUNCTION when
    called with a prefix argument. The FUNCTION still receives the
    prefix argument."
      (let ((name (intern (format "ha/%s-BOL" function))))
        `(progn
           (defun ,name (p)
             ,(format
               "Call `%s', but move to the beginning of the line when called with a prefix argument."
               function)
             (interactive "P")
             (when p
               (forward-line 0))
             (call-interactively ',function))
           ',name)))
  #+END_SRC

  And we re-bind them to functions that use them.

  #+BEGIN_SRC elisp
    (global-set-key [remap paredit-kill] (bol-with-prefix paredit-kill))
    (global-set-key [remap org-kill-line] (bol-with-prefix org-kill-line))
    (global-set-key [remap kill-line] (bol-with-prefix kill-line))

    (global-set-key (kbd "C-k") (bol-with-prefix kill-line))
  #+END_SRC

** Hydra Sequences

   I’m starting to appreciate the [[https://github.com/abo-abo/hydra][Hydra project]].

   #+BEGIN_SRC elisp
     (require 'hydra)

     (defhydra hydra-zoom (global-map "<f9>")
       "zoom"
       ("+" text-scale-increase "in")
       ("=" text-scale-increase "in")
       ("-" text-scale-decrease "out"))
   #+END_SRC

   Change window configuration and then return to the old
   configuration with [[http://www.emacswiki.org/emacs/WinnerMode][winner-mode]].  Use =Control-C Arrow= keys to
   cycle through window/frame configurations.

   #+BEGIN_SRC elisp
     (winner-mode 1)

     (defhydra hydra-winner (global-map "<f9> c")
       "zoom"
       ("<left>" winner-undo "undo-window")
       ("<right>" winner-redo "redo-window"))
   #+END_SRC


   Easily manipulate the size of the windows using the arrow keys in a
   particular buffer window.

   #+BEGIN_SRC elisp
     (require 'windmove)

     (defun hydra-move-splitter-left (arg)
       "Move window splitter left."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (shrink-window-horizontally arg)
         (enlarge-window-horizontally arg)))

     (defun hydra-move-splitter-right (arg)
       "Move window splitter right."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (enlarge-window-horizontally arg)
         (shrink-window-horizontally arg)))

     (defun hydra-move-splitter-up (arg)
       "Move window splitter up."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (enlarge-window arg)
         (shrink-window arg)))

     (defun hydra-move-splitter-down (arg)
       "Move window splitter down."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (shrink-window arg)
         (enlarge-window arg)))

     (defhydra hydra-splitter (global-map "<f9>")
       "splitter"
       ("<left>" hydra-move-splitter-left)
       ("<down>" hydra-move-splitter-down)
       ("<up>" hydra-move-splitter-up)
       ("<right>" hydra-move-splitter-right))
   #+END_SRC

* Loading and Finding Files
** Projectile

   The Projectile project is a nifty way to run commands and search
   for files in a particular "project". Its necessity is less now that
   IDO with flexible matching seems to always just find what I need.

   Still...

   #+BEGIN_SRC elisp
     (when (require 'projectile nil t)
       (require 'projectile)
       (projectile-global-mode))
   #+END_SRC

** Dired Options

    The associated group name isn't too useful when viewing the dired
    output.

#+BEGIN_SRC elisp
  (setq ls-lisp-use-insert-directory-program nil)
#+END_SRC

    This enhancement to dired hides the ugly details until you hit
    '(' and shows the details with ')'. I also change the [...] to a
    simple asterisk.

#+BEGIN_SRC elisp
  (when (require 'dired-details nil t)
    (dired-details-install)
    (setq dired-details-hidden-string "* "))
#+END_SRC

    The ability to create a dired buffer based on searching for files
    in a directory tree with =find-name-dired= is fantastic. The
    [[http://www.masteringemacs.org/articles/2011/03/25/working-multiple-files-dired/][following magic]] optimizes this approach:

    #+BEGIN_SRC elisp
    (require 'find-dired)
    (setq find-ls-option '("-print0 | xargs -0 ls -od" . "-od"))
    #+END_SRC

    The [[http://www.masteringemacs.org/articles/2014/04/10/dired-shell-commands-find-xargs-replacement/][dired-x project]] seems useful:

    #+BEGIN_SRC elisp
      (add-hook 'dired-load-hook
                (lambda ()
                  (load "dired-x")))
    #+END_SRC
** Tramp

   The ability to edit files on remote systems is a wonderful win,
   since it means I don't need to have my Emacs environment running on
   remote machines (still a possibility, just not a requirement).

   According to [[http://www.gnu.org/software/emacs/manual/html_node/tramp/Filename-Syntax.html][the manual]], I can access a file over SSH, via:

   #+BEGIN_EXAMPLE
   /ssh:10.52.224.67:blah
   #+END_EXAMPLE

   If I set the default method to SSH, I can do this:

   #+BEGIN_EXAMPLE
   /10.52.224.67:blah
   #+END_EXAMPLE

   So, let's do it...

   #+BEGIN_SRC elisp
     (setq tramp-default-method "ssh")
   #+END_SRC

   Come back someday, and see if the [[https://github.com/dougm/vagrant-tramp][vagrant-tramp]] project starts
   working, as that would be nice to access files like:

   #+BEGIN_EXAMPLE
   /vagrant:collectd-server:/var/chef/cache/chef-stacktrace.out
   #+END_EXAMPLE*

** Editing Root Files

   According to [[http://emacs-fu.blogspot.com/2013/03/editing-with-root-privileges-once-more.html][Emacs Fu]], we can use the wonderful Tramp to edit
   Root-owned files, as in:

   #+BEGIN_SRC elisp
     (defun ha/find-file-as-root ()
       "Like `ido-find-file, but automatically edit the file with
     root-privileges (using tramp/sudo), if the file is not writable by
     user."
       (interactive)
       (let ((file (ido-read-file-name "Edit as root: ")))
         (unless (file-writable-p file)
           (setq file (concat "/sudo:root@localhost:" file)))
         (find-file file)))
   #+END_SRC

   The trick, as always, is finding the correct keybinding... but I
   have the =C-c f= as prefix for loading all sorts of files...

   #+BEGIN_SRC elisp
   (global-set-key (kbd "C-c f r") 'ha/find-file-as-root)
   #+END_SRC

** IDO (Interactively DO Things)

    According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

#+BEGIN_SRC elisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (flx-ido-mode 1)
#+END_SRC

    According to [[https://gist.github.com/rkneufeld/5126926][Ryan Kneufeld]], we could make IDO work
    vertically, which is much easier to read. For this, I use
    [[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertically]]:

    #+BEGIN_SRC elisp
    (require 'ido-vertical-mode)
    (ido-mode 1)
    (ido-vertical-mode 1)

    ; I like up and down arrow keys:
    (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
    #+END_SRC

** SMEX

    Built using [[*IDO%20(Interactively%20DO%20Things)][IDO]].

#+BEGIN_SRC elisp
  (require 'smex)
  (smex-initialize) ; Can be omitted. This might cause a (minimal) delay

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-z") 'smex)  ;; Zap to char isn't so helpful
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; This is our old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC

   Not crazy about =zap-to-char= being so close to the very useful
   =M-x= sequence, so...

#+BEGIN_SRC elisp
  (global-set-key (kbd "M-z") 'smex-major-mode-commands)
#+END_SRC
** Grep for my Notes

   I have a voluminous amount of org-mode text files I routinely need
   search and filter.

   I use the standard [[http://emacswiki.org/emacs/GrepMode#toc1][grep package]] in Emacs, but need a later
   version of Gnu Grep. On Mac OS X, run these two commands:

   #+BEGIN_EXAMPLE
   brew tap homebrew/dupes
   brew install homebrew/dupes/grep
   #+END_EXAMPLE

   I also use [[http://beyondgrep.com][ack]] and the [[http://geoff.greer.fm/2011/12/27/the-silver-searcher-better-than-ack/][Silver Searcher]] (but for different uses).

   #+BEGIN_EXAMPLE
    brew install ack
    brew install ag
   #+END_EXAMPLE

   The [[https://github.com/jhelwig/ack-and-a-half][ack-and-a-half]] project requires the following:

  #+BEGIN_SRC elisp
    (when (require 'ack-and-a-half nil t)
      ;; This value sometimes gets set to null... hrm.
      (unless ack-and-a-half-executable
        (setq ack-and-a-half-executable "/usr/local/bin/ack"))

      ;; Not sure why org mode isn’t something we can limit searches:
      (add-to-list 'ack-and-a-half-mode-type-default-alist '(org-mode "org"))

      ;; Create shorter aliases
      (defalias 'ack 'ack-and-a-half)
      (defalias 'ack-same 'ack-and-a-half-same)
      (defalias 'ack-find-file 'ack-and-a-half-find-file)
      (defalias 'ack-find-file-same 'ack-and-a-half-find-file-same)

      (define-key personal-global-map (kbd "M-a") 'ack-and-a-half)
      (define-key personal-global-map (kbd "a") 'ack-and-a-half-same))
#+END_SRC

   However, I need an /indexing/ approach to searching through my
   notes, and since I'm usually on a Mac, I might as well use the
   /Spotlight/ service that is already running:

#+BEGIN_SRC elisp
  (setq locate-command "mdfind")  ;; Use Mac OS X's Spotlight
  (global-set-key (kbd "C-c f l") 'locate)
#+END_SRC

   The following function wraps =locate-with-filter= to only grab
   =org-mode= files:

#+BEGIN_SRC elisp
  (defun locate-org-files (search-string)
    (interactive "sSearch string: ")
    (locate-with-filter search-string ".org$"))

  (global-set-key (kbd "C-c f o") 'locate-org-files)
#+END_SRC

   We /could/ limit the location that Spotlight request searches:

#+BEGIN_SRC elisp :tangle no
  (defun locate-my-org-files (search-string)
    (let ((tech (concat (getenv "HOME") "/technical"))
          (pers (concat (getenv "HOME") "/personal"))
          (note (concat (getenv "HOME") "/notes"))
          (jrnl (concat (getenv "HOME") "/journal")))
      (-flatten (list "mdfind"
               (if (file-exists-p tech) (list "-onlyin" tech))
               (if (file-exists-p pers) (list "-onlyin" pers))
               (if (file-exists-p note) (list "-onlyin" note))
               (if (file-exists-p jrnl) (list "-onlyin" jrnl))
               "-interpret" search-string))))

  (setq locate-make-command-line 'locate-my-org-files)
#+END_SRC

   However, the problem with locate, is it doesn't show me any
   context. My [[file:bin/find-notes][find-notes]] script uses both =mdfind= and =grep= to both
   better search and display some useful context.

   Just need to wrap that in a function:

#+BEGIN_SRC elisp
  (defun find-notes (words)
    "Uses my 'find-notes' shell script as a better grep
  utility. Not only does it show the results in a clickable list,
  it also highlights the result, allowing us to put more context in
  the output."
    (interactive "sSearch for words:")
    (let ((program (concat (getenv "HOME") "/bin/find-notes"))
          (buffer-name (concat "*find-notes: " words "*")))
      (call-process program nil buffer-name t words)
      (switch-to-buffer buffer-name)
      (read-only-mode 1)
      (grep-mode)
      (toggle-truncate-lines)
      (beginning-of-buffer)
      (dolist (word (split-string words))
        (highlight-regexp word))))

  (global-set-key (kbd "C-x C-n") 'find-notes)
#+END_SRC

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file
   listing available, just not turned on.

#+BEGIN_SRC elisp
  (require 'recentf)
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (global-set-key (kbd "C-c f f") 'recentf-open-files)
#+END_SRC

** Backup Settings

    This setting moves all backup files to a central location.
    Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

#+BEGIN_SRC elisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (ha/emacs-subdirectory "backups")))))
#+END_SRC

   Make backups of files, even when they're in version control

#+BEGIN_SRC elisp
  (setq vc-make-backup-files t)
#+END_SRC

** Save Place

    The [[http://www.emacswiki.org/emacs/SavePlace][Save Place]] mode will... well, save your place in between
    Emacs sessions.

#+BEGIN_SRC elisp
  (require 'saveplace)
  (setq-default save-place t)
#+END_SRC

    With version 24.4 of Emacs, we can save all files when Emacs
    looses frame focus.

#+BEGIN_SRC elisp
  (add-hook 'focus-out-hook (lambda () (save-some-buffers t)))
#+END_SRC

    We won't turn that on until I am fully using the next version.

* Completion
** Auto Insertion

   Just beginning to get a collection of templates to automatically
   insert if a blank file is loaded.

   #+BEGIN_SRC elisp
     (add-hook 'find-file-hook 'auto-insert)
     (auto-insert-mode 1)
   #+END_SRC

   This line will create the =auto-insert-alist= variable that I can
   add to later.

** Auto Complete

   This feature scans the code and suggests completions for what you
   are typing. Useful at times ... annoying at others.

#+BEGIN_SRC elisp
  (when (require 'auto-complete-config nil t)
    (add-to-list 'ac-dictionary-directories (ha/emacs-subdirectory "ac-dict"))

    (set-default 'ac-sources
                 '(ac-source-abbrev
                   ac-source-dictionary
                   ac-source-yasnippet
                   ac-source-words-in-buffer
                   ac-source-words-in-same-mode-buffers
                   ac-source-semantic))

    (ac-config-default)
    (global-auto-complete-mode t))
#+END_SRC

   Note that we specify where a dictionary lives for each specific
   language, and if for some reason, a mode isn't getting the "AC"
   minor mode, you can add to it with this magic:

#+BEGIN_SRC elisp :tangle no
  (dolist (m '(python-mode js2-mode clojure-mode))
    (add-to-list 'ac-modes m))
#+END_SRC

** Yasnippets

   The [[https://github.com/capitaomorte/yasnippet][yasnippet project]] allows me to create snippets of code that
   can be brought into a file, based on the language.

#+BEGIN_SRC elisp
  (require 'yasnippet)
  (yas-global-mode 1)
#+END_SRC

   Helper function so that we can automatically expand a snippet
   programmatically, which makes it easier to do this with
   auto-insert:

   #+BEGIN_SRC elisp
     (defun yas--expand-by-uuid (mode uuid)
       "Exapnd snippet template in MODE by its UUID"
       (yas-expand-snippet
        (yas--template-content
         (yas--get-template-by-uuid mode uuid))))
   #+END_SRC

   Inside the =snippets= directory should be directories for each
   mode, e.g.  =clojure-mode= and =org-mode=. This connects the mode
   with the snippets.

#+BEGIN_SRC elisp
    (add-to-list 'yas-snippet-dirs (ha/emacs-subdirectory "snippets"))
#+END_SRC

   [[https://code.google.com/p/js2-mode/][js2-mode]] is good, but its name means that Yas' won't automatically
   link it to its =js-mode=. This little bit of magic does the linking:

#+BEGIN_SRC elisp :tangle no
    (add-hook 'js2-mode-hook '(lambda ()
                                (make-local-variable 'yas-extra-modes)
                                (add-to-list 'yas-extra-modes 'js-mode)
                                (yas-minor-mode 1)))
#+END_SRC

** Abbreviation Mode

   Using the built-in [[http://www.emacswiki.org/emacs/AbbrevMode][Abbreviation Mode]], and setting it up globally.

   #+BEGIN_SRC elisp
     (setq-default abbrev-mode t)
   #+END_SRC

   Stop asking whether to save newly added abbrev when quitting Emacs.

   #+BEGIN_SRC elisp
     (setq save-abbrevs nil)
   #+END_SRC

   While you can make abbreviations in situ, I figured I should
   /pre-load/ a bunch that I use, but make a distinction between
   abbreviations that would be available globally, and in particular
   modes (especially the text modes, like org-mode):
   \([^"]+?\)"
   #+BEGIN_SRC elisp
     (define-abbrev-table 'global-abbrev-table
         '(("8ha" "Howard Abrams")
           ("8fun" "function")
           ("8l" "lambda")))
   #+END_SRC

   This allows me to write =8ha= as =Howard Abrams=.

   #+BEGIN_SRC elisp
     (define-abbrev-table 'text-mode-abbrev-table
       '(("8js" "JavaScript")
         ("8cs" "CoffeeScript")
         ("8os" "OpenStack")
         ("8ng" "AngularJS")
         ("8wd" "Workday")
         ("btw" "by the way")
         ("note" "*Note:*")))
   #+END_SRC

   *Note:* Capitalizing the first letter, i.e. =Btw=, expands the
   abbreviation with an initial capital, i.e. =By the way= ... Sweet.

*** Spelling Correction with Abbreviation Mode

    According to [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][this discussion]], we can correct a misspelled word
    with =C-x C-i= and it will use the abbreviation mode to
    automatically correct that word...as long as you misspell it the
    same way each time.

    #+BEGIN_SRC elisp
      (define-key ctl-x-map "\C-i" 'endless/ispell-word-then-abbrev)

      (defun endless/ispell-word-then-abbrev (p)
        "Call `ispell-word'. Then create an abbrev for the correction made.
      With prefix P, create local abbrev. Otherwise it will be global."
        (interactive "P")
        (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
          (call-interactively 'ispell-word)
          (setq aft (downcase (or (thing-at-point 'word) "")))
          (unless (string= aft bef)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob"))
            (define-abbrev
              (if p global-abbrev-table local-abbrev-table)
              bef aft))))

      (setq save-abbrevs t)
      (setq-default abbrev-mode t)
    #+END_SRC

** Spell Checking

   I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses the built-in
   spell-check settings of [[https://www.gnu.org/software/ispell/][ispell]].

   Seems like I would want this automatically turned on for all text
   modes (but not for log files).

   #+BEGIN_SRC elisp
     (dolist (hook '(text-mode-hook org-mode-hook))
       (add-hook hook (lambda () (flyspell-mode 1))))

     (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
       (add-hook hook (lambda () (flyspell-mode -1))))
   #+END_SRC

   The downside of using single quotes, like ’ is that the ispell
   dictionary doesn’t recognize it as an apostrophe, so don’t is often
   looked at as incorrect.

   #+BEGIN_SRC elisp
   (eval-after-load "ispell"
     '(add-to-list 'ispell-local-dictionary-alist '(nil
                                                   "[[:alpha:]]"
                                                   "[^[:alpha:]]"
                                                   "['‘’]"
                                                   t
                                                   ("-d" "en_US")
                                                   nil
                                                   utf-8)))
   #+END_SRC

   Just not sure which of the three major spell checking systems to
   use. Currently, liking [[*ASpell][ASpell]] at this point.

*** ISpell

    Setting this to the /American/ dictionary seems to make it work
    better with Homebrew.

    #+BEGIN_SRC elisp :tangle no
     (setq ispell-dictionary "american")
    #+END_SRC

   To build a /personal/ dictionary hash (seems important now), do
   this:

   #+BEGIN_SRC sh :tangle no
     touch ~/.dictionary.txt
     buildhash ~/.ispell-personal.dict /usr/local/lib/english.aff ~/.dictionary.txt.hash
   #+END_SRC

   Then, we can use it like:

   #+BEGIN_SRC elisp :tangle no
     (setq ispell-personal-dictionary
         (concat (getenv "HOME") "/.ispell-personal.dict"))
   #+END_SRC

*** ASpell

    Seems that the [[http://aspell.net/][ASpell]] is better supported than the old ISpell.

    #+BEGIN_SRC sh :tangle no
    brew install aspell
    #+END_SRC

    And then configure it with the following:

    #+BEGIN_SRC elisp
      (setq ispell-program-name "aspell")
      (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))
      (setq ispell-dictionary "american")
    #+END_SRC

    To get Flyspell to work with Aspell, I need to do this:

    #+BEGIN_SRC elisp
    (setq ispell-list-command "--list")
    #+END_SRC

*** Hunspell

    Hunspell supposedly works better with internationalization and
    ligatures, so maybe we will try it sometime. If I do, this is what
    I need to set up:

    #+BEGIN_SRC sh :tangle no
    brew install hunspell
    #+END_SRC

    Download [[http://archive.services.openoffice.org/pub/mirror/OpenOffice.org/contrib/dictionaries/en_US.zip][this dictionary archive]] and unzip it in ~/Library/Spelling

    #+BEGIN_SRC elisp :tangle no
    (setq ispell-program-name "hunspell")
    (setq ispell-extra-args '("-d en_US"))
    (setq ispell-dictionary "en_US")
    #+END_SRC

** Online Thesaurus

   Using [[http://www.emacswiki.org/emacs/thesaurus.el][thesaurus.el]] to access the [[https://words.bighugelabs.com/][Big Huge Labs' Online Thesaurus]]
   while editing my expressive literary style in my text files.

#+BEGIN_SRC elisp
  (when (require 'thesaurus nil t)
    (thesaurus-set-bhl-api-key-from-file "~/.emacs.d/bighugelabs.apikey.txt")

    (define-key personal-global-map (kbd "t") 'thesaurus-choose-synonym-and-replace))
#+END_SRC

* Miscellaneous Settings
** Line Numbers

    Turn =linum-mode= on/off with =Command-K= (see the [[*Macintosh][Macintosh]]
    section above).  However, I turn this on automatically for
    programming modes.

#+BEGIN_SRC elisp
  (add-hook 'prog-mode-hook 'linum-mode)
#+END_SRC

    If we make the line numbers a fixed size, then increasing or
    decreasing the font size doesn't truncate the numbers:

#+BEGIN_SRC elisp
  (defun fix-linum-size ()
    (interactive)
    (set-face-attribute 'linum nil :height 110))

  (add-hook 'linum-mode-hook 'fix-linum-size)
#+END_SRC

    If we alternate between line numbers and no-line numbers, I also
    have to turn on/off the fringe. Actually, this is really only
    useful when giving presentations.

    #+BEGIN_SRC elisp
      (defun linum-off-mode ()
        "Toggles the line numbers as well as the fringe. This allows me
      to maximize the screen estate."
        (interactive)
        (if linum-mode
            (progn
              (fringe-mode '(0 . 0))
              (linum-mode -1))
          (fringe-mode '(8 . 0))
          (linum-mode 1)))

        (global-set-key (kbd "A-C-K") 'linum-off-mode)
        (global-set-key (kbd "s-C-K") 'linum-off-mode)  ;; For Linux
    #+END_SRC

    I'm intrigued with the [[https://github.com/coldnew/linum-relative][linum-relative]] mode (especially since I can
    toggle between them). The idea is that I can see the line that I
    want to jump to (like one 9 lines away), and then =C-9 C-n= to
    quickly pop to it.

#+BEGIN_SRC elisp
  (if (not (require 'linum-relative nil t))

      ;; If this isn't installed, we'll just toggle between showing and
      ;; not showing the line numbers.
      (progn
        (global-set-key (kbd "A-k") 'linum-mode)
        (global-set-key (kbd "s-k") 'linum-mode))   ;; For Linux

    ;; Otherwise, let's take advantage of the relative line numbering:
    (defun linum-new-mode ()
      "If line numbers aren't displayed, then display them.
       Otherwise, toggle between absolute and relative numbers."
      (interactive)
      (if linum-mode
          (linum-relative-toggle)
        (linum-mode 1)))

    (global-set-key (kbd "A-k") 'linum-new-mode)
    (global-set-key (kbd "s-k") 'linum-new-mode))   ;; For Linux
#+END_SRC

** Smart Scan

    Use the =M-n= to search the buffer for the word the cursor is
    currently pointing. =M-p= to go backwards.

#+BEGIN_SRC elisp
  (load-library "smart-scan")
#+END_SRC

** Strip Whitespace on Save

    When I save, I want to always, and I do mean always strip all
    trailing whitespace from the file.

#+BEGIN_SRC elisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Uniquify

    Get rid of silly <1> and <2> to buffers with the same file name,
    using [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][uniquify]].

#+BEGIN_SRC elisp
  (require 'uniquify)
#+END_SRC

** Better Searching and Visual Regular Expressions

    Only after you've started an =isearch-forward= do you wish you had
    regular expressions available, so why not just switch those defaults?

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") 'isearch-forward)
  (global-set-key (kbd "C-M-r") 'isearch-backward)
#+END_SRC

    The [[https://github.com/benma/visual-regexp.el][Visual Regular Expressions]] project highlights the matches
    while you try to remember the differences between Perl's regular
    expressions and Emacs'...

    Begin with =C-c r= then type the regexp. To see the highlighted
    matches, type =C-c a= before you hit 'Return' to accept it.

  #+BEGIN_SRC elisp
    (require 'visual-regexp)
    (define-key global-map (kbd "C-c r") 'vr/replace)
    (define-key global-map (kbd "C-c q") 'vr/query-replace)

    ;; if you use multiple-cursors, this is for you:
    (define-key global-map (kbd "C-c m") 'vr/mc-mark)
  #+END_SRC

** Flycheck

    [[https://github.com/flycheck/flycheck][Flycheck]] seems to be quite superior to good ol' Flymake.

#+BEGIN_SRC elisp
  (when (require 'flycheck nil t)
    (add-hook 'after-init-hook #'global-flycheck-mode))
#+END_SRC

    The most interesting aspect is that it doesn't support Clojure.

** Hungry Delete

   With this [[http://endlessparentheses.com//hungry-delete-mode.html][free feature]], deleting any space, deletes ALL spaces.
   Not sure if I like it, or not.

   #+BEGIN_SRC elisp
     (require 'hungry-delete)
     (global-hungry-delete-mode)
   #+END_SRC

* Org-Mode

  See [[file:emacs-org.org][emacs-org-mode.el]] for details on my [[http://www.orgmode][Org-Mode]] settings.

#+BEGIN_SRC elisp
  (require 'init-org-mode)
#+END_SRC

* Programming Languages
** Fixme in Comments

   Wanting to play around with the concept of highlighting certain
   comments with the TODO or FIXME keywords:

#+BEGIN_SRC elisp
  (when (require 'fic-mode nil t)
    (add-hook 'js2-mode-hook 'turn-on-fic-mode)
    (add-hook 'coffee-mode-hook 'turn-on-fic-mode)
    (add-hook 'python-mode-hook 'turn-on-fic-mode)
    (add-hook 'clojure-mode-hook 'turn-on-fic-mode)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-fic-mode))
#+END_SRC

** Emacs Lisp

   Sure, everything here is in Emacs Lisp, but this section helps me write more of that.

*** Paredit

    Gotta load me up my wonderful world of Paredit, which is used for
    more than just Emacs Lisp.

    #+BEGIN_SRC elisp
      (require 'paredit)
    #+END_SRC

    The most important change to Emacs Lisp is colorizing the
    variables:

    #+BEGIN_SRC elisp
      (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)

      (when (featurep 'paredit)
        (add-hook 'emacs-lisp-mode-hook (lambda () (paredit-mode t))))
    #+END_SRC

*** Auto Insert

    Most of my Emacs Lisp code is =org-mode= format, but I have times
    where I might as well insert some goodies:

    #+BEGIN_SRC elisp
      (eval-after-load 'autoinsert
        '(define-auto-insert
           '("\\.el" . "Emacs Lisp")
           '(lambda ()
               (yas--expand-by-uuid 'emacs-lisp-mode "header"))))
    #+END_SRC

*** Prettify Symbols

   Might as well pretty up the lambdas, and other functions using the
   new 24.4 prettify-symbols-mode:

   This approach seems to work and looks pretty good:

   #+BEGIN_SRC elisp
     (when (fboundp 'global-prettify-symbols-mode)
         (defconst lisp--prettify-symbols-alist
           '(("lambda"  . ?λ)
             ("curry"   . ?»)
             ("rcurry"  . ?«)
             ("comp"    . ?∘)
             ("compose" . ?∘)
             ("."       . ?•)))

         (global-prettify-symbols-mode 1))
   #+END_SRC

   Words with dashes don't separate words in Lisp:

   #+BEGIN_SRC elisp
     (dolist (c (string-to-list ":_-?!#*"))
       (modify-syntax-entry c "w" emacs-lisp-mode-syntax-table))
   #+END_SRC

   *Note:*: Need to change this to work with the v24.4 super-word.

*** Insert Comment of Eval

    While writing and documenting Emacs Lisp code, it would be helpful
    to insert the results of evaluation of an s-expression directly
    into the code as a comment:

    #+BEGIN_SRC elisp
      (defun eval-and-comment-output ()
        "Add the output of the sexp as a comment after the sexp"
        (interactive)
        (save-excursion
          (end-of-line)
          (condition-case nil
              (princ (concat " ; -> " (pp-to-string (eval (preceding-sexp))))
                     (current-buffer))
            (error (message "Invalid expression")))))
    #+END_SRC

    And since it is Emacs Lisp, let’s bind globally:

    #+BEGIN_SRC elisp
      (global-set-key (kbd "C-x e") 'eval-and-comment-output)
    #+END_SRC
** Clojure

   See [[file:emacs-clojure.org][emacs-clojure.el]] for details on working with [[http://clojure.org][Clojure]].
   Not sure if I should just load it directly, like:

#+BEGIN_SRC elisp
  (require 'init-clojure)
#+END_SRC

   Or if I should load it after the Clojure mode kicks in?

#+BEGIN_SRC elisp :tangle no
  (eval-after-load 'clojure-mode '(require 'init-clojure))
#+END_SRC

** Java

   Eh ... why use Java anymore?

** Python

   See [[file:emacs-python.org][emacs-python.el]] for details on working with Python.
   Not sure if I should just load it directly, like:

#+BEGIN_SRC elisp :tangle no
  (load-library "init-python")
#+END_SRC

** JavaScript

   See [[file:emacs-javascript.org][emacs-javascript.el]] for details on working with JavaScript.

#+BEGIN_SRC elisp :tangle no
;;  (load-library "init-javascript")
#+END_SRC

** HTML, CSS and other Web Programming

   See [[file:emacs-web.org][emacs-web.el]] for details on working with HTML and its ilk.

#+BEGIN_SRC elisp :tangle no
  (load-library "init-web")
#+END_SRC

* Tools
** Git

   Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.

#+BEGIN_SRC elisp
  (require 'magit)
  (global-set-key (kbd "M-C-g") 'magit-status)
  (define-key personal-global-map (kbd "g") 'magit-status)
#+END_SRC

   I like having Magit to run in a /full screen/ mode, and took this
   =defadvice= idea from [[https://github.com/magnars/.emacs.d/blob/master/setup-magit.el][Sven Magnars]]:

#+BEGIN_SRC elisp
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
#+END_SRC

   Now, we have to have the =q= command recover the window session
   that was stored in a window register:

#+BEGIN_SRC elisp
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))

  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
#+END_SRC

   I install and use the [[https://github.com/syohex/emacs-git-gutter-fringe][Git Gutter Fringe]] as it works better with
   windowing versions of Emacs.

#+BEGIN_SRC elisp
  (if (window-system)
      (when (require 'git-gutter-fringe nil t)
        (global-git-gutter-mode +1)
        (setq-default indicate-buffer-boundaries 'left)
        (setq-default indicate-empty-lines +1)))
#+END_SRC

   To see a /blame mode/, use either =vc-annotate= (=C-x v g=) or
   =magit-blame-mode=.

   Perhaps we can do [[https://github.com/sigma/magit-gh-pulls][Github pull requests]] from within Emacs, after
   reading [[http://endlessparentheses.com/merging-github-pull-requests-from-emacs.html][this blog entry]]. Just do =# g g= in Magit to list the pull
   requests.

   #+BEGIN_SRC elisp
     (when (require 'magit-gh-pulls nil t)
           (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls))
   #+END_SRC

** Markdown

   Don't use Markdown nearly as much as I used to, but I'm surprised
   that the following extension-associations aren't the default:

#+BEGIN_SRC elisp
  (autoload 'markdown-mode "markdown-mode.el"
     "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
#+END_SRC

   Using the =surround= function, I create some wrapper
   functions to make it easier to bold text in Markdown files:

#+BEGIN_SRC elisp
  (defun markdown-bold () "Wraps the region with double asterisks."
    (interactive)
    (surround-text "**"))
  (defun markdown-italics () "Wraps the region with asterisks."
    (interactive)
    (surround-text "*"))
  (defun markdown-code () "Wraps the region with equal signs."
    (interactive)
    (surround-text "`"))
#+END_SRC

   Now I can associate some keystrokes to =markdown-mode=:

#+BEGIN_SRC elisp
  (add-hook 'markdown-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'markdown-bold)
          (local-set-key (kbd "s-b") 'markdown-bold)    ;; For Linux
          (local-set-key (kbd "A-i") 'markdown-italics)
          (local-set-key (kbd "s-i") 'markdown-italics)
          (local-set-key (kbd "A-=") 'markdown-code)
          (local-set-key (kbd "s-=") 'markdown-code)))
#+END_SRC

** Wiki

   Now that Atlassian changed this Wiki system so that [[https://code.google.com/p/confluence-el/][confluence.el]]
   doesn't work anymore (yeah, not an improvement, Atlassian), I can
   still use the =confluence-edit-mode= for anything with a =.wiki=
   extension.

#+BEGIN_SRC elisp
  (autoload 'confluence-edit-mode "confluence-edit-mode.el"
     "Major mode for editing Wiki documents" t)
  (add-to-list 'auto-mode-alist '("\\.wiki\\'" . confluence-edit-mode))
#+END_SRC

   I would also like to create and use some formatting wrappers.

#+BEGIN_SRC elisp
  (defun wiki-bold () "Wraps the region with single asterisks."
    (interactive)
    (surround-text "*"))
  (defun wiki-italics () "Wraps the region with underbars."
    (interactive)
    (surround-text "_"))
  (defun wiki-code () "Wraps the region with curly brackets."
    (interactive)
    (surround-text "{{" "}}"))
#+END_SRC

   Now I can associate some keystrokes to =markdown-mode=:

#+BEGIN_SRC elisp
  (add-hook 'confluence-edit-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'wiki-bold)
          (local-set-key (kbd "A-i") 'wiki-italics)
          (local-set-key (kbd "A-=") 'wiki-code)))
#+END_SRC

** PlantUML and Graphviz

   Install the Graphviz project using Homebrew:

#+BEGIN_SRC sh :tangle no
  brew install graphviz
  brew link graphviz
  brew install plantuml
#+END_SRC

   To get [[http://plantuml.sourceforge.net/download.html][PlantUML]] working in Emacs, first, download the Jar and place
   in the =~/bin= directory. We then set the "mode" working for
   editing the files:

#+BEGIN_SRC elisp
  (setq plantuml-jar-path (concat (getenv "HOME") "/bin/plantuml.jar"))
#+END_SRC

   Second, to get [[http://zhangweize.wordpress.com/2010/08/25/creating-uml-images-by-using-plantuml-and-org-babel-in-emacs/][PlantUML]] working in org-mode, set a different variable:

#+BEGIN_SRC elisp
  (setq org-plantuml-jar-path (concat (getenv "HOME") "/bin/plantuml.jar"))
#+END_SRC

* Applications
** Web Browsing

   This section became involved, and has moved on to [[file:emacs-browser.org][emacs-browser]]
   file.

   #+BEGIN_SRC elisp
   (require 'init-browser)
   #+END_SRC

** EShell

  See [[file:emacs-eshell.org][emacs-eshell.el]] for details of configuring and using EShell.

#+BEGIN_SRC elisp
  (require 'init-eshell)
#+END_SRC

** Circe

   I find reading Twitter and IRC in Emacs a good idea. Really. Small
   bits of the Emacs window are accessible and whatnot.

#+BEGIN_SRC elisp
  (require 'circe nil t)
#+END_SRC

** Chatting

   Using the [[http://www.emacswiki.org/emacs/JabberEl][jabber.el]] project to connect up to Google Talk and what
   not. To begin, make sure you =brew install gnutls=

#+BEGIN_SRC elisp
  (when (require 'jabber nil t)
    (setq starttls-use-gnutls t
          starttls-gnutls-program "gnutls-cli"
          starttls-extra-arguments '("--starttls" "--insecure"))
    (setq
     jabber-history-enabled t
     jabber-use-global-history nil
     jabber-backlog-number 40
     jabber-backlog-days 30)

    (defun my-jabber-chat-delete-or-bury ()
      (interactive)
      (if (eq 'jabber-chat-mode major-mode)
          (condition-case e
              (delete-frame)
            (error
             (if (string= "Attempt to delete the sole visible or iconified frame"
                          (cadr e))
                 (bury-buffer))))))

    (define-key jabber-chat-mode-map [escape]
      'my-jabber-chat-delete-or-bury)

    (when (require 'autosmiley nil t)
      (add-hook 'jabber-chat-mode-hook 'autosmiley-mode)))
#+END_SRC

  To chat simply press: =C-x C-j C-c= ... hahaha. I doubt I can
  remember that one. Perhaps.

* Technical Artifacts

** Setting up the Exec Path

   Make sure that =PATH= variable for finding binary files can
   is the same as what Emacs will look for binary files. To do that,
   we use the [[https://github.com/ajsquared/env-var-import][env-var-import]] project.

   By default, it will only import the value of the environment
   variable defined in =env-var-import-exec-path-var= and set
   =exec-path= to that value. =env-var-import-exec-path-var= defaults
   to =PATH= but is customizable.

  #+BEGIN_SRC elisp
  (require 'env-var-import)
  (env-var-import)
  #+END_SRC

   If the =env-var-import= project isn't installed, I need to do that by
   hand using the following code:

   #+BEGIN_SRC elisp :tangle no
     (when window-system
       (let ((path-from-shell (shell-command-to-string "/bin/bash -l -c 'echo $PATH'")))
         (setenv "PATH" path-from-shell)
         (setq exec-path (split-string path-from-shell path-separator))))
   #+END_SRC

** Configure the Graphical Settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, call the 'mac' stuff... which will still work
   for Linux too.

   #+BEGIN_SRC elisp
     (if (window-system)
        (require 'init-client)
      (require 'init-server))
   #+END_SRC

** Load up the Local Configuration

  Before we finish, we need to check if there is a local file for us
  to load and evaluate.

  #+BEGIN_SRC elisp :tangle no
  (let ((local-file "~/.emacs.d/elisp/init-local.el"))
    (when (file-exists-p local-file)
      (load-file local-file)
      (message "Loaded machine-specific settings: %s" local-file)))
  #+END_SRC

  However, we can assume that the local file has been tangled and
  provides the =init-local= key:

  #+BEGIN_SRC elisp
  (catch 'error
    (require 'init-local))
  #+END_SRC

  After the first load, we can reload this with a require:

  #+BEGIN_SRC elisp
    (provide 'init-main)
  #+END_SRC

  Before you can build this on a new system, make sure that you put
  the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
